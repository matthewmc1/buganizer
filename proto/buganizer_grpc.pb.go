// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: buganizer.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	IssueService_CreateIssue_FullMethodName   = "/buganizer.IssueService/CreateIssue"
	IssueService_GetIssue_FullMethodName      = "/buganizer.IssueService/GetIssue"
	IssueService_UpdateIssue_FullMethodName   = "/buganizer.IssueService/UpdateIssue"
	IssueService_ListIssues_FullMethodName    = "/buganizer.IssueService/ListIssues"
	IssueService_AddComment_FullMethodName    = "/buganizer.IssueService/AddComment"
	IssueService_AddAttachment_FullMethodName = "/buganizer.IssueService/AddAttachment"
)

// IssueServiceClient is the client API for IssueService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Issue service for managing bugs and feature requests
type IssueServiceClient interface {
	// Create a new issue
	CreateIssue(ctx context.Context, in *CreateIssueRequest, opts ...grpc.CallOption) (*Issue, error)
	// Get issue by ID
	GetIssue(ctx context.Context, in *GetIssueRequest, opts ...grpc.CallOption) (*Issue, error)
	// Update an existing issue
	UpdateIssue(ctx context.Context, in *UpdateIssueRequest, opts ...grpc.CallOption) (*Issue, error)
	// List issues with filtering
	ListIssues(ctx context.Context, in *ListIssuesRequest, opts ...grpc.CallOption) (*ListIssuesResponse, error)
	// Add a comment to an issue
	AddComment(ctx context.Context, in *AddCommentRequest, opts ...grpc.CallOption) (*Comment, error)
	// Add attachment to an issue
	AddAttachment(ctx context.Context, in *AddAttachmentRequest, opts ...grpc.CallOption) (*Attachment, error)
}

type issueServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIssueServiceClient(cc grpc.ClientConnInterface) IssueServiceClient {
	return &issueServiceClient{cc}
}

func (c *issueServiceClient) CreateIssue(ctx context.Context, in *CreateIssueRequest, opts ...grpc.CallOption) (*Issue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Issue)
	err := c.cc.Invoke(ctx, IssueService_CreateIssue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *issueServiceClient) GetIssue(ctx context.Context, in *GetIssueRequest, opts ...grpc.CallOption) (*Issue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Issue)
	err := c.cc.Invoke(ctx, IssueService_GetIssue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *issueServiceClient) UpdateIssue(ctx context.Context, in *UpdateIssueRequest, opts ...grpc.CallOption) (*Issue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Issue)
	err := c.cc.Invoke(ctx, IssueService_UpdateIssue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *issueServiceClient) ListIssues(ctx context.Context, in *ListIssuesRequest, opts ...grpc.CallOption) (*ListIssuesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListIssuesResponse)
	err := c.cc.Invoke(ctx, IssueService_ListIssues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *issueServiceClient) AddComment(ctx context.Context, in *AddCommentRequest, opts ...grpc.CallOption) (*Comment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Comment)
	err := c.cc.Invoke(ctx, IssueService_AddComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *issueServiceClient) AddAttachment(ctx context.Context, in *AddAttachmentRequest, opts ...grpc.CallOption) (*Attachment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Attachment)
	err := c.cc.Invoke(ctx, IssueService_AddAttachment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IssueServiceServer is the server API for IssueService service.
// All implementations must embed UnimplementedIssueServiceServer
// for forward compatibility.
//
// Issue service for managing bugs and feature requests
type IssueServiceServer interface {
	// Create a new issue
	CreateIssue(context.Context, *CreateIssueRequest) (*Issue, error)
	// Get issue by ID
	GetIssue(context.Context, *GetIssueRequest) (*Issue, error)
	// Update an existing issue
	UpdateIssue(context.Context, *UpdateIssueRequest) (*Issue, error)
	// List issues with filtering
	ListIssues(context.Context, *ListIssuesRequest) (*ListIssuesResponse, error)
	// Add a comment to an issue
	AddComment(context.Context, *AddCommentRequest) (*Comment, error)
	// Add attachment to an issue
	AddAttachment(context.Context, *AddAttachmentRequest) (*Attachment, error)
	mustEmbedUnimplementedIssueServiceServer()
}

// UnimplementedIssueServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedIssueServiceServer struct{}

func (UnimplementedIssueServiceServer) CreateIssue(context.Context, *CreateIssueRequest) (*Issue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateIssue not implemented")
}
func (UnimplementedIssueServiceServer) GetIssue(context.Context, *GetIssueRequest) (*Issue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIssue not implemented")
}
func (UnimplementedIssueServiceServer) UpdateIssue(context.Context, *UpdateIssueRequest) (*Issue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateIssue not implemented")
}
func (UnimplementedIssueServiceServer) ListIssues(context.Context, *ListIssuesRequest) (*ListIssuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListIssues not implemented")
}
func (UnimplementedIssueServiceServer) AddComment(context.Context, *AddCommentRequest) (*Comment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddComment not implemented")
}
func (UnimplementedIssueServiceServer) AddAttachment(context.Context, *AddAttachmentRequest) (*Attachment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAttachment not implemented")
}
func (UnimplementedIssueServiceServer) mustEmbedUnimplementedIssueServiceServer() {}
func (UnimplementedIssueServiceServer) testEmbeddedByValue()                      {}

// UnsafeIssueServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IssueServiceServer will
// result in compilation errors.
type UnsafeIssueServiceServer interface {
	mustEmbedUnimplementedIssueServiceServer()
}

func RegisterIssueServiceServer(s grpc.ServiceRegistrar, srv IssueServiceServer) {
	// If the following call pancis, it indicates UnimplementedIssueServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&IssueService_ServiceDesc, srv)
}

func _IssueService_CreateIssue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateIssueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IssueServiceServer).CreateIssue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IssueService_CreateIssue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IssueServiceServer).CreateIssue(ctx, req.(*CreateIssueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IssueService_GetIssue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIssueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IssueServiceServer).GetIssue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IssueService_GetIssue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IssueServiceServer).GetIssue(ctx, req.(*GetIssueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IssueService_UpdateIssue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateIssueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IssueServiceServer).UpdateIssue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IssueService_UpdateIssue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IssueServiceServer).UpdateIssue(ctx, req.(*UpdateIssueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IssueService_ListIssues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListIssuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IssueServiceServer).ListIssues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IssueService_ListIssues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IssueServiceServer).ListIssues(ctx, req.(*ListIssuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IssueService_AddComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IssueServiceServer).AddComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IssueService_AddComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IssueServiceServer).AddComment(ctx, req.(*AddCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IssueService_AddAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IssueServiceServer).AddAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IssueService_AddAttachment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IssueServiceServer).AddAttachment(ctx, req.(*AddAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IssueService_ServiceDesc is the grpc.ServiceDesc for IssueService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IssueService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "buganizer.IssueService",
	HandlerType: (*IssueServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateIssue",
			Handler:    _IssueService_CreateIssue_Handler,
		},
		{
			MethodName: "GetIssue",
			Handler:    _IssueService_GetIssue_Handler,
		},
		{
			MethodName: "UpdateIssue",
			Handler:    _IssueService_UpdateIssue_Handler,
		},
		{
			MethodName: "ListIssues",
			Handler:    _IssueService_ListIssues_Handler,
		},
		{
			MethodName: "AddComment",
			Handler:    _IssueService_AddComment_Handler,
		},
		{
			MethodName: "AddAttachment",
			Handler:    _IssueService_AddAttachment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "buganizer.proto",
}

const (
	SLAService_CalculateSLATarget_FullMethodName = "/buganizer.SLAService/CalculateSLATarget"
	SLAService_CheckSLARisk_FullMethodName       = "/buganizer.SLAService/CheckSLARisk"
	SLAService_GetSLAStats_FullMethodName        = "/buganizer.SLAService/GetSLAStats"
)

// SLAServiceClient is the client API for SLAService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// SLA service for managing Service Level Agreements
type SLAServiceClient interface {
	// Calculate SLA target date based on priority and severity
	CalculateSLATarget(ctx context.Context, in *CalculateSLARequest, opts ...grpc.CallOption) (*SLATarget, error)
	// Check if issues are at risk of SLA breach
	CheckSLARisk(ctx context.Context, in *CheckSLARiskRequest, opts ...grpc.CallOption) (*CheckSLARiskResponse, error)
	// Get SLA statistics for a component or team
	GetSLAStats(ctx context.Context, in *GetSLAStatsRequest, opts ...grpc.CallOption) (*SLAStats, error)
}

type sLAServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSLAServiceClient(cc grpc.ClientConnInterface) SLAServiceClient {
	return &sLAServiceClient{cc}
}

func (c *sLAServiceClient) CalculateSLATarget(ctx context.Context, in *CalculateSLARequest, opts ...grpc.CallOption) (*SLATarget, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SLATarget)
	err := c.cc.Invoke(ctx, SLAService_CalculateSLATarget_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLAServiceClient) CheckSLARisk(ctx context.Context, in *CheckSLARiskRequest, opts ...grpc.CallOption) (*CheckSLARiskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckSLARiskResponse)
	err := c.cc.Invoke(ctx, SLAService_CheckSLARisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLAServiceClient) GetSLAStats(ctx context.Context, in *GetSLAStatsRequest, opts ...grpc.CallOption) (*SLAStats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SLAStats)
	err := c.cc.Invoke(ctx, SLAService_GetSLAStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SLAServiceServer is the server API for SLAService service.
// All implementations must embed UnimplementedSLAServiceServer
// for forward compatibility.
//
// SLA service for managing Service Level Agreements
type SLAServiceServer interface {
	// Calculate SLA target date based on priority and severity
	CalculateSLATarget(context.Context, *CalculateSLARequest) (*SLATarget, error)
	// Check if issues are at risk of SLA breach
	CheckSLARisk(context.Context, *CheckSLARiskRequest) (*CheckSLARiskResponse, error)
	// Get SLA statistics for a component or team
	GetSLAStats(context.Context, *GetSLAStatsRequest) (*SLAStats, error)
	mustEmbedUnimplementedSLAServiceServer()
}

// UnimplementedSLAServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSLAServiceServer struct{}

func (UnimplementedSLAServiceServer) CalculateSLATarget(context.Context, *CalculateSLARequest) (*SLATarget, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CalculateSLATarget not implemented")
}
func (UnimplementedSLAServiceServer) CheckSLARisk(context.Context, *CheckSLARiskRequest) (*CheckSLARiskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckSLARisk not implemented")
}
func (UnimplementedSLAServiceServer) GetSLAStats(context.Context, *GetSLAStatsRequest) (*SLAStats, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSLAStats not implemented")
}
func (UnimplementedSLAServiceServer) mustEmbedUnimplementedSLAServiceServer() {}
func (UnimplementedSLAServiceServer) testEmbeddedByValue()                    {}

// UnsafeSLAServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SLAServiceServer will
// result in compilation errors.
type UnsafeSLAServiceServer interface {
	mustEmbedUnimplementedSLAServiceServer()
}

func RegisterSLAServiceServer(s grpc.ServiceRegistrar, srv SLAServiceServer) {
	// If the following call pancis, it indicates UnimplementedSLAServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SLAService_ServiceDesc, srv)
}

func _SLAService_CalculateSLATarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalculateSLARequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLAServiceServer).CalculateSLATarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SLAService_CalculateSLATarget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLAServiceServer).CalculateSLATarget(ctx, req.(*CalculateSLARequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLAService_CheckSLARisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckSLARiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLAServiceServer).CheckSLARisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SLAService_CheckSLARisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLAServiceServer).CheckSLARisk(ctx, req.(*CheckSLARiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLAService_GetSLAStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSLAStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLAServiceServer).GetSLAStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SLAService_GetSLAStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLAServiceServer).GetSLAStats(ctx, req.(*GetSLAStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SLAService_ServiceDesc is the grpc.ServiceDesc for SLAService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SLAService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "buganizer.SLAService",
	HandlerType: (*SLAServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CalculateSLATarget",
			Handler:    _SLAService_CalculateSLATarget_Handler,
		},
		{
			MethodName: "CheckSLARisk",
			Handler:    _SLAService_CheckSLARisk_Handler,
		},
		{
			MethodName: "GetSLAStats",
			Handler:    _SLAService_GetSLAStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "buganizer.proto",
}

const (
	NotificationService_SendSlackNotification_FullMethodName         = "/buganizer.NotificationService/SendSlackNotification"
	NotificationService_RegisterWebhook_FullMethodName               = "/buganizer.NotificationService/RegisterWebhook"
	NotificationService_UpdateNotificationPreferences_FullMethodName = "/buganizer.NotificationService/UpdateNotificationPreferences"
)

// NotificationServiceClient is the client API for NotificationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Notification service for integrations with messaging platforms
type NotificationServiceClient interface {
	// Send notification to Slack
	SendSlackNotification(ctx context.Context, in *NotificationRequest, opts ...grpc.CallOption) (*NotificationResponse, error)
	// Register webhook URL for notifications
	RegisterWebhook(ctx context.Context, in *RegisterWebhookRequest, opts ...grpc.CallOption) (*RegisterWebhookResponse, error)
	// Update notification preferences
	UpdateNotificationPreferences(ctx context.Context, in *UpdateNotificationPreferencesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type notificationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationServiceClient(cc grpc.ClientConnInterface) NotificationServiceClient {
	return &notificationServiceClient{cc}
}

func (c *notificationServiceClient) SendSlackNotification(ctx context.Context, in *NotificationRequest, opts ...grpc.CallOption) (*NotificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NotificationResponse)
	err := c.cc.Invoke(ctx, NotificationService_SendSlackNotification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) RegisterWebhook(ctx context.Context, in *RegisterWebhookRequest, opts ...grpc.CallOption) (*RegisterWebhookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterWebhookResponse)
	err := c.cc.Invoke(ctx, NotificationService_RegisterWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) UpdateNotificationPreferences(ctx context.Context, in *UpdateNotificationPreferencesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NotificationService_UpdateNotificationPreferences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationServiceServer is the server API for NotificationService service.
// All implementations must embed UnimplementedNotificationServiceServer
// for forward compatibility.
//
// Notification service for integrations with messaging platforms
type NotificationServiceServer interface {
	// Send notification to Slack
	SendSlackNotification(context.Context, *NotificationRequest) (*NotificationResponse, error)
	// Register webhook URL for notifications
	RegisterWebhook(context.Context, *RegisterWebhookRequest) (*RegisterWebhookResponse, error)
	// Update notification preferences
	UpdateNotificationPreferences(context.Context, *UpdateNotificationPreferencesRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedNotificationServiceServer()
}

// UnimplementedNotificationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNotificationServiceServer struct{}

func (UnimplementedNotificationServiceServer) SendSlackNotification(context.Context, *NotificationRequest) (*NotificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendSlackNotification not implemented")
}
func (UnimplementedNotificationServiceServer) RegisterWebhook(context.Context, *RegisterWebhookRequest) (*RegisterWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterWebhook not implemented")
}
func (UnimplementedNotificationServiceServer) UpdateNotificationPreferences(context.Context, *UpdateNotificationPreferencesRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNotificationPreferences not implemented")
}
func (UnimplementedNotificationServiceServer) mustEmbedUnimplementedNotificationServiceServer() {}
func (UnimplementedNotificationServiceServer) testEmbeddedByValue()                             {}

// UnsafeNotificationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationServiceServer will
// result in compilation errors.
type UnsafeNotificationServiceServer interface {
	mustEmbedUnimplementedNotificationServiceServer()
}

func RegisterNotificationServiceServer(s grpc.ServiceRegistrar, srv NotificationServiceServer) {
	// If the following call pancis, it indicates UnimplementedNotificationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NotificationService_ServiceDesc, srv)
}

func _NotificationService_SendSlackNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).SendSlackNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_SendSlackNotification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).SendSlackNotification(ctx, req.(*NotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_RegisterWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).RegisterWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_RegisterWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).RegisterWebhook(ctx, req.(*RegisterWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_UpdateNotificationPreferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNotificationPreferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).UpdateNotificationPreferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_UpdateNotificationPreferences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).UpdateNotificationPreferences(ctx, req.(*UpdateNotificationPreferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NotificationService_ServiceDesc is the grpc.ServiceDesc for NotificationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NotificationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "buganizer.NotificationService",
	HandlerType: (*NotificationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendSlackNotification",
			Handler:    _NotificationService_SendSlackNotification_Handler,
		},
		{
			MethodName: "RegisterWebhook",
			Handler:    _NotificationService_RegisterWebhook_Handler,
		},
		{
			MethodName: "UpdateNotificationPreferences",
			Handler:    _NotificationService_UpdateNotificationPreferences_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "buganizer.proto",
}

const (
	SearchService_SearchIssues_FullMethodName = "/buganizer.SearchService/SearchIssues"
	SearchService_SaveView_FullMethodName     = "/buganizer.SearchService/SaveView"
	SearchService_GetView_FullMethodName      = "/buganizer.SearchService/GetView"
	SearchService_ListViews_FullMethodName    = "/buganizer.SearchService/ListViews"
)

// SearchServiceClient is the client API for SearchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Search service for querying and filtering issues
type SearchServiceClient interface {
	// Search issues with complex queries
	SearchIssues(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	// Save a view (saved search)
	SaveView(ctx context.Context, in *SaveViewRequest, opts ...grpc.CallOption) (*SavedView, error)
	// Get a saved view
	GetView(ctx context.Context, in *GetViewRequest, opts ...grpc.CallOption) (*SavedView, error)
	// List saved views for a user or team
	ListViews(ctx context.Context, in *ListViewsRequest, opts ...grpc.CallOption) (*ListViewsResponse, error)
}

type searchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSearchServiceClient(cc grpc.ClientConnInterface) SearchServiceClient {
	return &searchServiceClient{cc}
}

func (c *searchServiceClient) SearchIssues(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, SearchService_SearchIssues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) SaveView(ctx context.Context, in *SaveViewRequest, opts ...grpc.CallOption) (*SavedView, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SavedView)
	err := c.cc.Invoke(ctx, SearchService_SaveView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) GetView(ctx context.Context, in *GetViewRequest, opts ...grpc.CallOption) (*SavedView, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SavedView)
	err := c.cc.Invoke(ctx, SearchService_GetView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) ListViews(ctx context.Context, in *ListViewsRequest, opts ...grpc.CallOption) (*ListViewsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListViewsResponse)
	err := c.cc.Invoke(ctx, SearchService_ListViews_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SearchServiceServer is the server API for SearchService service.
// All implementations must embed UnimplementedSearchServiceServer
// for forward compatibility.
//
// Search service for querying and filtering issues
type SearchServiceServer interface {
	// Search issues with complex queries
	SearchIssues(context.Context, *SearchRequest) (*SearchResponse, error)
	// Save a view (saved search)
	SaveView(context.Context, *SaveViewRequest) (*SavedView, error)
	// Get a saved view
	GetView(context.Context, *GetViewRequest) (*SavedView, error)
	// List saved views for a user or team
	ListViews(context.Context, *ListViewsRequest) (*ListViewsResponse, error)
	mustEmbedUnimplementedSearchServiceServer()
}

// UnimplementedSearchServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSearchServiceServer struct{}

func (UnimplementedSearchServiceServer) SearchIssues(context.Context, *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchIssues not implemented")
}
func (UnimplementedSearchServiceServer) SaveView(context.Context, *SaveViewRequest) (*SavedView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveView not implemented")
}
func (UnimplementedSearchServiceServer) GetView(context.Context, *GetViewRequest) (*SavedView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetView not implemented")
}
func (UnimplementedSearchServiceServer) ListViews(context.Context, *ListViewsRequest) (*ListViewsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListViews not implemented")
}
func (UnimplementedSearchServiceServer) mustEmbedUnimplementedSearchServiceServer() {}
func (UnimplementedSearchServiceServer) testEmbeddedByValue()                       {}

// UnsafeSearchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SearchServiceServer will
// result in compilation errors.
type UnsafeSearchServiceServer interface {
	mustEmbedUnimplementedSearchServiceServer()
}

func RegisterSearchServiceServer(s grpc.ServiceRegistrar, srv SearchServiceServer) {
	// If the following call pancis, it indicates UnimplementedSearchServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SearchService_ServiceDesc, srv)
}

func _SearchService_SearchIssues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SearchIssues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_SearchIssues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SearchIssues(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_SaveView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveViewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SaveView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_SaveView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SaveView(ctx, req.(*SaveViewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_GetView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetViewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).GetView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_GetView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).GetView(ctx, req.(*GetViewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_ListViews_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListViewsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).ListViews(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_ListViews_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).ListViews(ctx, req.(*ListViewsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SearchService_ServiceDesc is the grpc.ServiceDesc for SearchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SearchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "buganizer.SearchService",
	HandlerType: (*SearchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchIssues",
			Handler:    _SearchService_SearchIssues_Handler,
		},
		{
			MethodName: "SaveView",
			Handler:    _SearchService_SaveView_Handler,
		},
		{
			MethodName: "GetView",
			Handler:    _SearchService_GetView_Handler,
		},
		{
			MethodName: "ListViews",
			Handler:    _SearchService_ListViews_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "buganizer.proto",
}

const (
	AuthService_AuthenticateWithGoogle_FullMethodName = "/buganizer.AuthService/AuthenticateWithGoogle"
	AuthService_ValidateToken_FullMethodName          = "/buganizer.AuthService/ValidateToken"
	AuthService_GetCurrentUser_FullMethodName         = "/buganizer.AuthService/GetCurrentUser"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Auth service for user authentication and authorization
type AuthServiceClient interface {
	// Authenticate with Google SSO
	AuthenticateWithGoogle(ctx context.Context, in *AuthenticateWithGoogleRequest, opts ...grpc.CallOption) (*AuthenticateResponse, error)
	// Validate token
	ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error)
	// Get current user
	GetCurrentUser(ctx context.Context, in *GetCurrentUserRequest, opts ...grpc.CallOption) (*User, error)
}

type authServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) AuthenticateWithGoogle(ctx context.Context, in *AuthenticateWithGoogleRequest, opts ...grpc.CallOption) (*AuthenticateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthenticateResponse)
	err := c.cc.Invoke(ctx, AuthService_AuthenticateWithGoogle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateTokenResponse)
	err := c.cc.Invoke(ctx, AuthService_ValidateToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetCurrentUser(ctx context.Context, in *GetCurrentUserRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, AuthService_GetCurrentUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
//
// Auth service for user authentication and authorization
type AuthServiceServer interface {
	// Authenticate with Google SSO
	AuthenticateWithGoogle(context.Context, *AuthenticateWithGoogleRequest) (*AuthenticateResponse, error)
	// Validate token
	ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error)
	// Get current user
	GetCurrentUser(context.Context, *GetCurrentUserRequest) (*User, error)
	mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) AuthenticateWithGoogle(context.Context, *AuthenticateWithGoogleRequest) (*AuthenticateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthenticateWithGoogle not implemented")
}
func (UnimplementedAuthServiceServer) ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateToken not implemented")
}
func (UnimplementedAuthServiceServer) GetCurrentUser(context.Context, *GetCurrentUserRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentUser not implemented")
}
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {}
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {}

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
	mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) {
	// If the following call pancis, it indicates UnimplementedAuthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthService_ServiceDesc, srv)
}

func _AuthService_AuthenticateWithGoogle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticateWithGoogleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).AuthenticateWithGoogle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_AuthenticateWithGoogle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).AuthenticateWithGoogle(ctx, req.(*AuthenticateWithGoogleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ValidateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_ValidateToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ValidateToken(ctx, req.(*ValidateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetCurrentUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetCurrentUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_GetCurrentUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetCurrentUser(ctx, req.(*GetCurrentUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "buganizer.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AuthenticateWithGoogle",
			Handler:    _AuthService_AuthenticateWithGoogle_Handler,
		},
		{
			MethodName: "ValidateToken",
			Handler:    _AuthService_ValidateToken_Handler,
		},
		{
			MethodName: "GetCurrentUser",
			Handler:    _AuthService_GetCurrentUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "buganizer.proto",
}
